### ✍️ Tangxt ⏳ 2020-11-29 🏷️ DOM

# 02-DOM 封装-链式风格

## ★Q&A

💡：为什么要用链式姿势封装一个 DOM 库？

因为我想进一步理解 jQuery 的设计思想

💡：链式风格是什么？

链式风格也称作 jQuery 风格，与对象风格不同的是，我们全局变量 `jQuery` 是个函数，而不是一个对象，我们在 `jQuery` 函数的原型上，也就是 `prototype` 旗下，添加了对元素**增删改查**的功能！

💡：为什么用 `$` 作为 `jQuery` 的别名？

因为它够短呀！

💡：如何实现链式操作？

为了实现链式操作，在使用 `jQuery("选择器")` 或 `$("选择器")` 选择页面元素时，应当返回一个可操作对应元素的对象，而不是元素本身。我们称这个对象为由 jQuery 函数构造的对象，简称为 **jQuery 对象**。

在 jQuery 对象中添加 `print` 属性，属性值为一个用于打印出选择元素的函数，函数的返回值为 `this` ，指向调用它的对象，即作为 jQuery 函数返回值的 jQuery 对象。函数与选择的元素构成闭包结构，这样我们就可以继续对元素进行操作，从而形成链式风格

``` js
window.$ = window.jQuery = function(selectors) {
  let elements = document.querySelectorAll(selectors)
  return {
    print() {
      console.log(elements)
      return this
    }
  }
}

// 选择 class 属性为 list 的所有元素并将它们打印出来
$(".list").print()
```

💡：内存优化处理？

每次调用 jQuery 对象中的函数都会**新占用一块地址**，从而导致内存浪费，所以我们可以：

1. 把 jQuery 对象的共有属性（函数）全部放在 `jQuery.prototype` 上 -> 对其使用别名 `jQuery.fn = jQuery.prototype` -> 将 jQuery 对象的原型指向 `jQuery.fn`（这一步真得有必要吗？`Object.create(jQuery.fn)`？） -> 使用 `constructor` 设置 jQuery 对象的构造函数 `jQuery`

2. 使用 `Object.assign` 为 jQuery 对象添加多个属性

我们写的 API 都在 jQuery 对象的原型对象上，也就是在 `jQuery.prototype` 旗下！

## ★查

1）$(selectors)（选择元素）

根据指定的 CSS 选择器选择所有元素，返回 jQuery 对象。

语法：

``` js
const $api = $(selectors)
```

参数：

* `selectors`：字符串，一个包含单个或多个匹配的选择器的字符串

实现：

``` js
// 别名
window.$ = window.jQuery = function(selectorsOrArrayOrTemplate) {
  let elements;
  // 重载
  if (typeof selectorsOrArrayOrTemplate === "string") {
    if (selectorsOrArrayOrTemplate[0] === "<") {
      elements = [create(selectorsOrArrayOrTemplate)];
    } else {
      elements = document.querySelectorAll(selectorsOrArrayOrTemplate);
    }
  } else if (selectorsOrArrayOrTemplate instanceof Array) {
    elements = selectorsOrArrayOrTemplate;
  }

  function create(string) {
    const template = document.createElement("template");
    template.innerHTML = string.trim();
    return template.content.firstChild;
  }
  // jQuery 对象的共有属性
  const api = Object.create(jQuery.prototype);
  Object.assign(api, {
    elements: elements,
    oldApi: selectorsOrArrayOrTemplate.oldApi,
    jquery: true,
  });
  // 闭包
  return api;
};
```

> `oldApi` 是旧的 jQuery 对象，每次你调用 API，都会返回一个新的 jQuery 对象！

一个疑问：`elements`这个属性的类型是不是只是数组类型比较好？

2）.each(fn)（遍历元素）

遍历元素列表，对每个元素执行一次指定的函数，返回 jQuery 对象。

语法：

``` js
const $api = $(selectors).each(fn(element, index))
```

实现：

``` js
{
  each(fn) {
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      fn.call(this, element, index);
    }
    return this;
  }
}
```

测试：

``` js
$('.list').each((ele, index) => {
  console.log(ele, index)
})
```

![each](assets/img/2020-11-29-18-50-00.png)

3）.find(selectors)（查找元素）

遍历元素里列表（数组类型），根据指定的 CSS 选择器选择元素，返回 jQuery 对象

语法：

``` js
const $api = $(selectorsOrArray).find(selectors)
```

参数：

* `selectorsOrArray`：字符串 or 数组
* `selectors`：字符串，选择器 or 选择器组

实现：

``` js
{
  find(selectors) {
    const array = [];
    this.each((element) => {
      array.push(...element.querySelectorAll(selectors));
    });
    array.oldApi = this;
    return jQuery(array);
  }
}
```

测试：

字符串选择器：

``` js
$('.container1').find('#one')
$('.container1').find('.list')
$('.container2').find('.list')
```

元素列表（数组类型的，可不是`NodeList`这样的伪数组）：

![数组类型的元素列表](assets/img/2020-11-30-00-02-28.png)

4）.end()（元素回退）
