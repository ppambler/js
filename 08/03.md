# 面向对象深度解析（3）

## TPR？

**1）Symbol？**

通过Symbol 可以在全局创建一个独一无二的值（注意，这并不是一个字符串值）

其语法很简单，直接 `Symbol()`即可生成一个值，而如果给它一个参数的话，如 `Symbol('xxx')`，那么这相当于是给这个值起了个叫 `xxx` 标注，当然，这个参数和Symbol出来的值没啥关系哈！

关于它的使用场景：如果我们不关心一个对象的某个属性的键值是多少的话，那么可以用 `Symbol()`来生成一个值，还有就是在class里边，我们要封装一个有私有调调的方法，即他人使用这个类的时候，即new一个对象出来的时候，是无法访问这个方法的，那么我们也可以把该方法Symbol化！

➹：[「每日一题」JS 中的 Symbol 是什么？ - 知乎](https://zhuanlan.zhihu.com/p/22652486)

**2）Java 的多态？**

事物在运行过程中存在不同的状态。例子：花木兰替父从军，花木兰在从军的时候暴露的属性和方法是来自于父亲的（向上转型），而在遇到心爱之人之后，花木兰她揭示了自己的真实身份，即此时她暴露的属性和方法才是真正属于她自己的！（向下转型）——花木兰在从军的过程中存在不同的属性和方法！

> 一个疑问：Java编译的时候做了什么？毕竟在涉及到对多态理解的时候，提及到「成员变量：编译看左边(父类),运行看左边(父类)」等等的文字描述！

➹：[JAVA的多态用几句话能直观的解释一下吗？ - 程序狗的回答 - 知乎](https://www.zhihu.com/question/30082151/answer/120520568)

**3）关于对面向对象之封装特性的一些误区？**

封装不是包装，与我们封装一个插件是两码事哈！面向对象的封装是指通过封装的过程能够控制类的属性和方法的可访问的方式！（关键点在于 **可访问** ）

总之，封装就是说：一部分的方法属性只能在这一个类里边访问，而其它外部是无法访问的，还有一部分是完全开放的，只要你实例化了这个类，那么都可以访问，还有一部分只能提供给自己的子类（继承了才可以访问）访问，而其它地方是访问不了的！

**4）扩展阅读？**

➹：[这样理解面向对象的封装，继承，多态是否正确？ - 知乎](https://www.zhihu.com/question/52767718)

➹：[面向对象编程的弊端是什么？ - 知乎](https://www.zhihu.com/question/20275578)


## ★封装

### ◇概述

- 面向对象里边的「封装」是面向对象语言的一个重要特性

- 封装：通过封装，控制类的属性与方法的可访问方式（信息隐藏大法）

- 关键字：private、public、protected
  - private：只有类的内部可访问
  - public：完成开发访问
  - protected：可供子类访问

> 我们日常使用一个类，那就是根据这个类，new一个实例出来，而这个实例能否访问类的成员属性或方法，得看我们是否用了public等关键字，当然，在JS 里边，一般类的成员属性和方法都是可访问的！

### ◇封装的好处

- 封装4个好处：

  1. 减少程序的耦合（程序与程序之间不会发生冲突）
  2. 自由修改类内部结构（随便修改封装，也可以说是接口里边的实现而不影响调用者，还有随意添加一些成员和方法……）
  3. 对成员准确的控制（提供3种访问权限，用于告知实例是否可访问，以及以什么样的方式访问）
  4. 隐藏隐私信息（如一些支付算法涉及到加密之类的，显然是类内部用的，即private的，如果有一些公共性的，那么就protected，然后继承了才可以用）

总之，针对不同的场景来为成员添加访问权限，而这会保证了程序的安全、以及程序的生态！

不过，很遗憾的是，ES6并咩有支持面向对象的封装特性！

那么是不是无法实现呢？——其实不是这样的，也是可以实现封装的，不过由于JS 代码是在前端的，即我们可以用浏览器来看到这些代码，所以关于封装的实现意义并咩有那么大！

当然，我们开发者还是希望有这个封装特性的，如TypeScript（JS的语法糖）就很香，毕竟它就支持如private、protected、public等关键字，即实现了面向对象的封装特性！

> ES6也可以实现封装，即实现成员私有，那就是用Symbol哈！

### ◇通过代码进一步了解封装

**1）PHP的封装**

People类：

![People类](assets/img/2019-12-04-14-24-05.png)

Student类：

![Student类](assets/img/2019-12-04-14-21-34.png)

测试：

```php
<?php

require_once('classes/student.php');

$xiaoming = new Student('xiaoming',175,70,1001,'Math');

echo $xiaoming -> say();
```

![say方法](assets/img/2019-12-04-14-29-29.png)

> 在公开的方法里边，居然可以访问到类的私有属性或私有方法！

如果你这样：

```php
echo $xiaoming -> sno;
```

那么：

![Student实例访问类的私有属性](assets/img/2019-12-04-14-33-35.png)

同理：

```
echo $xiaoming -> subject;
```

这样，也是无法访问 `subject` 这个成员是属性的！

接下来测试一下People这个类：

```php
<?php

require_once('classes/people.php');

$xiaohong = new People('xiaohong',160,40);

echo $xiaohong -> name
```

结果：

![People的protected之name属性](assets/img/2019-12-04-16-58-25.png)

同理：

```php
echo $xiaohong -> intro() //Fatal error: Uncaught Error: Call to protected method People::intro() from……
echo $xiaohong -> drink() //Fatal error: Uncaught Error: Call to private method People::drink() from……
```

以上就是封装的好处了，我们在定义Student类的时候，只是想让学生说句自我介绍的话，即定义了一个public的 `say`方法，而其它的成员属性和成员方法是不需要用到的，因此我们就有私有化了，而且由于继承了People这个类，那么People旗下的protected化的成员属性和成员方法Student实例都可以用。

总之，我们定义一个类，如果不想让类旗下的某些属性、方法被外界知道，即被实例知道，那么我们就private呗！反之，如果想让大家都知道，那么就public呗！

好了，这就是所谓的面向对象的封装性了，这非常实用，如果学过Java、Python等纯面向对象语言，你就会发现它们的程序都是用一个一个的类垒起来的！而像PHP这样的，它就不是纯面向对象的语言了，毕竟它可以面向对象开发，也可以面向过程开发！

### ◇通过一些旁门左道来让ES6实现类的成员属性、方法私有化

我们在ES6的class特性写代码的时候，都用一个下划线 `_`来标注这个属性是私有的，如 `_xxx`，不过这是我们人为赋予的意义，即希望这个属性、方法不要让外界访问，但实际上这是可以访问的！（类似于此地无银三百两）

因此，我们利用了`Symbol()`这个值来让我们的成员属性、方法私有化，关于`Symbol()`这个值，它表示唯一的值，即在当前页面永远不可能重复的值!

做法：

``` js
const doAjax = Symbol('doAjax')
class HTTP {
  [doAjax](options) {}
}
```

效果：

![实现成员属性、方法的私有化](assets/img/2019-12-04-20-34-32.png)

除了可以让成员方法私有化以外，成员属性也可以私有化！做法一样哈！

## ★多态

- 多态：成员方法的重载和重写
- 强类型面向对象语言才有意义

所谓的重载：在同一个类里边，存在叫同样名字的成员方法，当然参数不一

所谓的重写：父类有个xxx的方法，子类继承了父类，但子类也写了一个叫xxx的方法

对于JS来说，由于是弱类型语言的缘故，多态的意义不大！

JS的多态有点肤浅：

``` js
class People {
  test(){
    return 1
  }
}
class Student extends People {
  test() {
    return 2
  }
}

let xiaoming = new Student()
xiaoming.test() //2

// 如果Student这个类的test方法注释掉了，那么xiaoming.test()的值就是 1了
```

如果JS是有类型的话，那么就会去根据这个xiaoming的类型去判断该执行是People的test，还是Student的test

总之，多态就是方法的重载与重写

> 一个接口（就是方法）它在不同的类里边有不同的表现，即，有不同的程序的体现，有不用的程序的执行，那么这就叫做面向对象里边类的多态了！

小结：

1. 在ES6里边完全掌握面向对象其实就只有继承，像是封装，我们就用 `Symbol()`实现了成员属性和成员方法的私有化！

2. 重载：在一个类里边，搞几个名字一样的成员方法，不过JS 和 PHP是不支持的；重写：就是子类重写父类的方法，JS的重写体现同PHP是一样的！

## ★面向过程和面向对象

### ◇区别

![面向过程和面向对象图示](assets/img/2019-12-04-22-13-00.png)

了解了面向对象的三大特性以后，我们反过来，反观一下面向对象，它相对应的一种开发模式是面向过程。

通过一个经典的例子「把大象装进冰箱」，来理解面向过程和面向对象。

作为一个有着「面向过程」世界观的程序员，那么「把大象装进冰箱」就会这么做：

``` js
// 面向过程：
function 大象装进冰箱() {
  // ……点点表示省略了一大堆程序
  打开冰箱……  //程序体1
  大象装入……  //程序体2
  关闭冰箱……  //程序体3
}
```

我们获取到一个冰箱之后，就会打开冰箱，然后把对象塞进去，最后关闭冰箱。这是一个过程，而且这是一个步骤顺序，已经指定好步骤顺序之后，就会按照这个步骤一步一步地去执行，去写相应的程序

我们按步骤与顺序去执行一个个的行为，而这也就成为了行为的集合了

而有着「面向对象」世界观的程序员则不是这样的，那么他们是怎样的呢？——他们会这样做：

先想想如何把一件事情抽象成一个对象出来，如一个对象有哪些属性和方法，而不是先想我要怎样才能做到，总之，要先想什么样的东西才能够做到「打开冰箱」……

冰箱它是一个类别，同样也是一个对象，那么这个类别它有哪些属性和方法呢？

有开门、放大象、关门这样的方法，还有一个属性「门」

门+3个方法就构成了我们要完成的这个程序的类别

通过把这些方法和这些属性包装到类里边去，然后实例化这个类别，就能实例化出来一个具体冰箱，然后再按照「开门、装大象、关门」这样的顺序去执行程序：

``` js
// 面向对象
class 冰箱 {
  constructor（）{
    this.门 = '冰箱门'
  }
  开门() {……}
  装东西() {……}
  关门() {……}
}

const 冰箱实例 = new 冰箱()
// 以下这3个步骤其实也是面向过程的步骤
// 但是，这是需要先经过面向对象这种包装的方式之后，然后再进行的面向过程
冰箱实例.开门()
冰箱实例.装东西()
冰箱实例.关门()
```

通过以上代码可以了解到：**面向对象是一种基于面向过程的一种编程思想**，换句话说，就是完成这个「把大象装冰箱」这个功能之前，我们要懂得要把这个程序里边一些主体的东西给**抽象出来成为类**，然后这个类通过实例化再成为具体的你在这个程序的执行过程当中的**一个对象**，然后再通过这个对象去执行相应的我们需要完成的整个程序的这样一个**方法**，最后，就完成整个「把大象装冰箱」的功能了！

话又说来，为啥「面向对象是一种基于面向过程的一种编程思想」呢？

因为你抽象了类以后，其里边所有的方法，实际上这些方法的内部，有些时候还是基于面向过程的！如「开门」这个方法，肯定会涉及到「触摸呈现拉着的手势」，然后「用力往身体这个方向拉」，最后「冰箱门打开了」，所以说这其实也是一个过程，但只是说这是我们一个类里边的一个过程，一个过程性的程序哈！

所以，面向对象和面向过程其实并不冲突，即你在写面向对象的时候，也会遇到写面向过程的，那么你在完成一个功能的时候可能是基于一个类去实例化来完成一个面向过程的这么一个程序

因此，大家需要注意的是：**面向对象和面向过程并不是完全分成两条路走的，而是相辅相成的**

### ◇面向对象的意义

![面向对象意义](assets/img/2019-12-05-17-34-49.png)

#### 数据结构化

回过头去看学习面向对象这种开发思想的时候，老师举了一些People、Student之类的类，但这些类显然离我们的编程要很远很远，因此，老师就写了一个可切换模式的tab（即选项卡或者说是一个插件）

可是面向对象的意义到底是什么呢？

这是数据结构化的问题，为啥这样说呢？

因为我们在写类的时候，其实类里边的属性和方法都是按照类这样的套路来写的

那么类的套路又是什么呢？——实际上就是集中化哈！

你的属性是集中在一起，你的方法也是集中在一起的，而且它们的意义都是成员属性和成员方法

其实做这样一个过程，即你面向对象抽象一个类出来，然后来写成员属性和成员方法，这整个这样的包装过程，实际上就是**数据的结构化过程**

我们日常中理解的数据是这样的：数字「`123`」、字符串「`'123'`」、JSON数据等等

但其实数据不是这样的。

数据是一切的一切，而一切的一切也都是数据

方法是数据吗？——是数据；属性是数据吗？——也是数据；变量是数据吗？——同样也是数据

还有数据类型是数据吗？——同样也是数据

总之，你要记住一切的编程都基于数据，最后都会变成0和1的数据，所以说，实际上，你在进行编程的时候，用面向对象的方式，实际上就是数据的结构化问题

或许，你会疑问「如果不用面向对象，那数据就没有结构化了吗？」

不用面向对象，也能让数据结构化，只是数据结构化的可行性可能变得更低，而且可能更难以管理

简而言之，你在平时用面向过程的时候，你就会发现变量东一个西一个，局部一个，全局一个，即变量一会声明在这儿，一会儿又声明在那儿，当然，如果你代码写得好一点的话，可能会写在一起然后看上去还是一个整体，但是你想一下，如果这个程序变复杂了呢？

如果你全部都是以面向过程的方式去写的话，那么你的变量会无处不在，那么这变量无处不在会代表着什么呢？

你以后进行管理的时候，这个程序成长为成千上万、上百万行代码的时候，你就会发现你的整个程序的数据体系会变得非常非常的散漫（零散；不集中。），那么这样会有什么样的后果呢？——后果如下：

1. 对代码的维护不利
2. 对代码的可读性不利
3. 不知道产品代码的版本迭代该怎么去做？
4. ……


所以说，为啥大家都要利用面向对象去包装一个自己的一个功能体呢？——原因就是因为我们希望的是数据结构化，再说的具体点就是，我们希望的是属性也好，方法也好，变量也好等等都要更加的结构化

#### 程序的结构化

既然说到了数据结构化，那么程序的结构化就不得不说了

我们的程序无非就是「顺序、判断、循环」

我们所写的程序无非就是这三点了：

按照顺序从第一行开始执行，直到最后一行，然后其中可能会涉及到判断，如「if xxx 就 doSomething」，如果遇到数组还会搞个循环去遍历

当然，在C语言里边还有goto，不过，它已经被淘汰了，因为它破会了程序的结构化！

我们说到「顺序、判断、循环」组成了一个程序的结构体，可这个「结构体」为啥说是 结构体呢？

原因是因为计算机它希望我们所写的程序是按「顺序、判断、循环」这样的一种程序结构体来写代码！而这样一来，计算机才会更好的解析我们所写出来的东西！而这叫做程序结构体啦！

我们的面向对象实际上是在程序结构化的这个基础上对数据进行抽象数据结构化！

而数据结构化的目的就在于更好的去对程序结构化进行管理，并不在于我们声明一个类是人，声明一个子类是Student，然后实例化了一个小明、小红，而这只是更方便我们去学习来做的！

而数据结构化它的真正意义是「更好的去管理我们的数据」，如果我们把这个「数据」的名字改了，如改成属性和方法，那么就是更好的去管理我们的属性和方法

回过头来，说说「结构化」的问题：

大家一定要明白，**计算机需要结构化**，原因如下：

举个最简单的例子来说，你的HTML、CSS、JS……代码，浏览器去解析这三样东西的时候，实际上这三样东西是「流」哈，那么「流」又是什么呢？——「流」就是一堆的字符串哈！

说白了，我们的HTML、CSS、JS都是字符串，对于计算机的浏览器程序来说，它就是字符串，浏览器解析的是什么呢？——解析的就是字符串哈！

那么对于「字符串」，浏览器是怎么去解析的呢？

显然，给我们的HTML代码变成DOM树，然后什么CSS渲染树之类的，那么这些「树」是什么呢？——是结构哈！

总而言之，计算机其实希望把我们所写的这些东西全部给结构化了，其实计算机的目的也是结构化，而我们开发者的目的则是从人的角度上说，能够把代码结构化掉！

总之，你要记住「计算机认为结构化是最简单的东西」，那么简单的前提又是什么呢？——**一定是抽象**哈！

抽象一个方法，抽象一个类的关键在哪儿 呢？——是让你的数据跟程序更加的有结构，更加的便于管理，更加的易读易维护易迭代。

所以说面向对象的编程的意义更大的是在于**数据结构化**！那么我们说小的意义呢？——那可能就是**复用**了！毕竟这面向对象有「继承」的概念，还有「实例化」这个概念，而这是不是就是复用呢？（显然是的哈！）

除了「复用」这个小意义以外，面向对象还有哪些意义呢？

一个更深层次的意义：

> 可以更好地防止程序之间的耦合（「封装」的意义就是如此！），然后更好地去管理我们的对象

面向对象它的大前提优势是：它的数据结构化，更好地便于我们，有利于我们对自己的程序进行管理，而这就是为啥我们要用面向对象的思想去编程的原因所在了！


之后会探讨如何用面向对象的姿势去写几个程序

---

**小结：**

计算机希望简单的那就是结构化，即我们所写的代码是结构化

还有，简单的前提是「如何去抽象？」，那我们要抽象是什么呢？——抽象方法和抽象类

总之，这是我们编程当中一个非常重要的一个特性（即面向对象），当然，你还得知道「面向对象不是所有地方都能用的 」，它要真正的在我们的程序当中抽离出对象来才行！

就拿「把大象装冰箱」这个例子来说，我们要完成这个例子，我们要完成这个功能的主要东西是啥？说白了，就是关键点是啥？——是大象跟冰箱哈！

那么我们能把大象和冰箱抽象出来吗？——显然这是可以的！

我们抽象出一个冰箱的功能，由于大象是被放进去的，所以大象它就咩有必要被抽象了，所以说，其实冰箱它有「门」的属性，它有「打开」的方法，它有「装东西」的方法，还有「关闭」的方法，而这就是把一个程序里边的某一个对象给抽离出来，然后成为一个类，如程序需要用到冰箱，我们针对这个冰箱抽象出了一些方法和属性，进而抽象成了一个类，然后我们再利用这个类的实例去进行我们程序功能编写，而这样一来，那我们对程序的管理就更加的优雅和便捷方便了！


以上就是我们所讲的面向对象编程了，对于JS 来说，这样的讲解已经算是非常完整了，因此，你得要认认真真的好好消化一下这三节内容哈！而这样一来，在针对面向对象编程的巩固和练习里边，就不会理解得那么难了。

总之，你要理解：

1. 理解 People和Student案例
2. 理解Tab案例
3. 理解封装了Ajax的HTTP类案例


## ★总结

- 关于把「大象装进冰箱」这个比喻，为啥要把冰箱当作是个class呢？冰箱它会自己开门呢？——冰箱它不能自动开门，是我们人类打开的，可这人类就类似于我们自己 写了这样一行代码：`new 冰箱().open()`啊！开发者就像是上帝一样，他们在程序世界里边创造着自己所期望的程序哈！(程序=算法+数据结构+代码组织结构)