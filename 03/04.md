### ✍️ Tangxt ⏳ 2021-02-23 🏷️ OO

# 04-this、对象继承-1

> 写在对象身上的方法，叫属性，从子类原型找的才是方法

### <mark>1）回顾 OO</mark>

1. 对象 = 数据 + 方法（可叫函数、过程、代码、程序）
   1. 它不是一个很神秘的东西，它的思想是很简单的
   2. 它提供了空间（命名空间，一个模块是一个命名空间、一个函数它内部也是命名空间，一个类里边也是一个命名空间）
2. 写法 -> 思想层面再怎么成熟，如果不落实到代码上，那都是空的、假的、扯淡的……
   1. 传统写法（构造函数）
      1. 混乱 -> 没有关键字`class`，难以区分这是构造函数还是`function` -> function 和类混淆
      2. 需要在原型上添加方法
   2. ES6 -> 兼容方面，用 babel 就好了
      1. class 关键字 -> class 就是 class，function 就是 function
      2. 方法 -> 就在`class`里边写
3. 原型 -> 有了 class 之后，它是不是废了呢？显然不是，它还是有很大的用途的
   1. 作用：给类加东西——所有实例有
   2. 原理：往上找 -> JS 语言支撑的功能，不需要我们自己实现
      1. 先找实例本身
      2. 找不到就找子类
      3. 如此反复 -> 最后基类 `Object`
      4. 再找不到 -> `undefined`
   3. 题外话：JS 这语言比较特别，语言天生自带`prototype`，而这是不太常见的，绝大多数的 OO 语言，有`prototype`这个概念，但都得自己动手来实现 -> 如 Java 要实现「往上找」的功能，就得自己通过代码来实现了，当然，会存在一些库来帮助我们这样做…… -> 总之，`prototype`并不是语言自带的东西
   4. 用途：
      1. 给类添加方法 -> 很常用，在某些场景下，如需要判断这个字符串是不是合法的 id，于是就在原型上加了方法了……
      2. 给系统类打补丁 `Array.prototype.filter=Array.prototype.filter||function (){};` -> 系统自带的`filter`比我们自己实现的性能更高！
4. 类型
   1. typeof -> 基本类型
      1. 检测对象 -> 不好 -> 因为检测出来都是 `object`，分不清了，而你又不能说它错，因为理论上说，它们确实是`object`，但这样检测，跟废话差不多，没有意义！所以，它适合基本类型
   2. instanceof -> 子级+父类
      1. 既能检测子类，也能检测父类，而这样做是对的 -> 因为在面向对象的思想当中，一个父类可以有多个子类，这些子类都是父类的特例，父类描述了这些子类的共有属性和操作。一个子类可以继承它的父类（或祖先类）中的属性和操作，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和操作。
   3. constructor -> 只检测子类，不检测父类
      1. 这不是语言自身规定的用法，而是各路的人自己探索出来的用法
      2. 它返回的是构造这个实例出来的那个函数（也叫类） -> 可间接作为判断类型的标准 -> 用得比较少，但在某些特殊场景下，用它贼鸡儿方便，而且用别的还真不行
5. 特性 -> 面向对象本身的特性，不管是啥介绍面向对象（无论哪种语言）的书，都会提到这 3 个特性 -> 这 3 个特性都有很丰富的含义
   1. 封装 -> 不让别人看到这个类里边都有什么东西
      1. 减低程序的复杂性 -> 关注的事越多，那精力就会越分散，最后写出来的东西就会越混乱 -> 不要关注我这个类怎么写出来的，你只管用我提供给你的这 3 个方法就完事儿了，管那么多干嘛呢？ -> 把具体的这个类的实现细节给封装起来，让它不可见
      2. 保护类里边的成员 -> **主要目标**
         1. 面向对象等等一系列的东西都是软件工程里边的工具，而软件工程这个学科它本身研究的就是「**如何防止人犯错误**」，我们都知道「**犯错误是常态，不犯错误不可能**」 -> 而保护成员就是**为了防止这个成员被意外的修改**，至少我们用了它，就可以加那一层保护了，这样使用者就无法直接去赋值、修改、操作我了 -> 安全性大大提高
   2. 继承 -> 从一个父类的基础上继承出来一个子类 -> 最大限度重用了父级的代码，同时可以把一些特征延续下来！
      1. this -> JS 的 this 很乱，一会儿是这个，一会儿是那个，而其它有面向对象特性的语言里的 this 是非常严谨、非常好的，唯独 JS 的 this 很乱 -> JS 作者之所以这样做是为了让语言变得更加简单
   3. 多态
      1. JS 语法层面不支持多态 -> 因为 JS 自身就是一个动态类型的语言，所以它不需要多态
      2. 我们写 JS，更多是利用它思想层面上的东西，如不用去深究这个东西到底是**谁搞出来**的，也不用深究这个东西到底是**谁来实现**的，反正我用就完事儿了！

我们用面向对象实际上就是在用它某个层面上的特性（3 个特性），如果这些特性都不用，那干脆用函数得了……

### <mark>2）课程目标</mark>

- this -> 乱
- 继承

第一个话题：this

1. 为什么 `this` 这么「乱」？好奇怪啊！怎么回事啊！为啥非得搞成这个样子啊！
2. `this`乱没关系，毕竟，我们无法改变，总不能买张机票去找 JS 作者好好聊说「给我把这个`this`改好……」 -> 所以，你更多的是去适应这个语言，而不是改变这个语言 -> 如何在`this`乱的情况下，让自己的代码不乱呢？

第二个话题：继承

1. 极其常见 -> 什么叫极其？随手就能看到一个例子 -> 几乎你所见到的所有的类型或者其它东西，都是继承的产物，几乎它都有一个父类
2. 价值 -> 继承的价值何在？
   1. 尽可能重用代码 -> 什么东西都从零开始的话，那么这就废了……
   2. 它是多态的一个支撑，没有继承，那就没有多态了！
3. 什么时候就想到要去用继承了？
   1. 公共的东西（属性和方法，类也就这两个东西） -> 抽取出来，没必要在每个类里边都搞一套，毕竟这样很没有意义，父类搞一套，大家一起用不香吗？ -> 这是继承最大的一个应用价值
4. 写法 -> 思想层面再怎么成熟，最后只飘在脑子里边是没有意义的！ -> 所以我们最终就要拿来用，而拿来用就是变成代码来用！而变成代码就需要写！
   1. 古典写法 -> 很乱
   2. ES6 -> 非常简洁、方便
5. 用 -> 用它来做一些事儿
   1. 平常干活时，这继承大部分情况下，其实是用来帮助我们实现一些带有功能的组件 -> 怎么做这些组件呢？ -> 这次课会做一个最初步的设计！ -> 真正对组件很深入，得在后边的课了……

### <mark>3）this</mark>

给 `this` 下一个最基本的一个结论性的东西，什么样的结论呢？如 `this` 到底是什么东西？到底是干什么的？怎么回事等等这一系列的东西……

一句话描述：它取决于一个东西——「谁在调用」

`this`这个东西用在哪儿呢？ -> 用于函数/方法内部，在函数之外的地方用它是没有意义的！

> 函数、方法不分家，它们俩是一个东西！

所以这取决于当前这个函数/方法是谁在调用？ -> 谁调用我，`this`就是谁，就怎么简单！

#### <mark>1、例子（用法）</mark>

在其它语言里边，`this`是固定的，如这样：

![this](assets/img/2021-02-23-12-28-31.png)

函数代码写好后，这个`this`就是固定的，就是指的某一个对象或者什么东西！

而在 JS 中，这是不一样的 -> 我们之所以说 JS `this`乱，是因为这`this`是能变的！

JS 有这么一个特点：全局的东西，都是属于`window`的

如：

``` js
function show(){
  alert(this);
}

show(); // window

//全局的东西——都是属于 window

// 等价于
window.show()
```

我们直接写`show()`就是一种简写姿势，即把`window.`给省了……

然而，我们说过，`this`是会变的

如函数`show`代码本身不变，但是随着我的用法不同，那么它的`this`可能也会有所不一样

如我们加个`'use strict;'` -> 这是 JS 作者搞出来的玩意儿，为自己年轻的时候所犯下的错而填的坑 -> 这叫严格模式！

简单来说，JS 这个语言，它其实天然有很多语法层面上的一些漏洞或者弱点之类的东西，而这个**严格模式它可以帮助咱们的 JS 运行在一个更加严格的一个状态之下**！ -> 这样的话，很多问题其实就可以得到解决了！

在严格模式下：

![this 是 undefined](assets/img/2021-02-23-13-47-40.png)

也许你会疑问：「全局的东西——都是属于`window`，这不是打脸吗？」

话说，你认为「全局的东西——都是属于 window」这个事本身严谨吗？

这是不严谨的 -> 因为 JS 早就已经不是只能工作在浏览器的状态之下了，JS 有没有可能工作在后台？比如 Node.js（出了很多年了，很多人在用，在 Node.js 下运行没毛病） ？然后台的 JS 根本就咩有 window 的概念

所以，在这种情况下，全局函数`show`并没有真正意义上属于谁的概念，就是一个函数，就是一个飘着的东西，就是全局的，不属于任何人……不然，你让 Node.js 怎么看？

总之，上边这个例子，主要是告诉我们`this`的第一个特别混乱的地方是：**JS 的`this`是动态的！** -> 说白了，`this`不是死的，它可以根据你的使用方法不同而随着改变！

当你加上`window`后：

![加 window](assets/img/2021-02-23-17-01-47.png)

#### <mark>2、`this`的值受什么影响？</mark>

1. 严格模式 -> 影响全局
2. 方法 -> 谁调用我`this`就是谁
3. 事件 -> `document.onclick = show` -> 谁触发事件？
4. 定时器

> 严格模式只影响全局的，其它东西都不管

💡：为啥严格模式下，定时器下的`this`还是`window`？

`setTimeout(show,100)` -> `this` 是 `window`

因为定时器是由浏览器触发的！不然，不触发就没人执行了……

所以这是由浏览器，也就是`window`间接执行这个`show`方法！

💡：为什么要设计`this`？

想要理解任何一个东西，最好的办法就是知道它为何要出现、为何会有这么一个东西……

如果这个世界没有`this`：

假如有这样的需求：调用一个方法弹出自己的名字

``` js
// 不用 this，那你就得根据使用者来确定类该怎么写了
// 而这显然是很愚蠢的行为，因为使用者万一取名叫 p2 呢？
class Person {
  fn() {
    alert(p.name)
  }
}
let p = new Person('blue')
p.fn()
```

总之，它的存在就是**方便我们使用当前实例**

➹：[JS 里为什么会有 this - 知乎](https://zhuanlan.zhihu.com/p/30164164)

💡：js 的`this`为什么乱？

JS 作者说：为了让 JS 更简单易用

可，我们开发者并没有觉得哪里简单易用啊？

要理解这么个事儿，需要对比其它语言来看：

几乎在所有的语言里边，函数这个东西，是不能单独存在的，比如 Java，你就只写函数，不写类，看看这是什么情况？

总之，函数是不能独立存在的，它必须得属于某一个类！

而这个时候，`this`就是不乱的，就指向当前对象！

而在 JS 里边，你可以发现，函数可以存在在各种各样的地方，如：

1. 给事件加个函数
2. 给定时器加个函数
3. 在某个类里边搞个函数
4. 还可以把函数赋值，赋给谁都行……

所以，`this`之所以那么乱，就是因为函数本身可以到处窜，如果函数是固定的，不能动，就死在那儿，不能走，那么`this`就会变得非常的简单了，因此，归根到底，JS 里边的`this`之所以那么乱，就是因为`function`特别灵活：

- 可以独立存在
- 可以给别人
- 可以……

这就是为什么说 JS`this`乱是为了让 JS 更简单易用 -> 也就是函数的锅……毕竟，函数是一等公民！

在其它语言里，如在 Java 里边使用定时器这个场景，之前说到，这些语言的函数无法独立出去，那么怎么用定时器呢？

很简单，带有定时器方法的这个类传给别人就行了（传给别人一个类，实际是实例），说白了，函数就没有离开过这个类，传给人家的是这个类，所以这样`this`就不混乱了…… -> 人家想要喝水，把水杯拿给他相当于是把水拿给了他

> JS `this` 乱的原因，就是因为函数它太灵活了！

---

如果能直接得出结论，那就不要搞那么多花里胡哨的东西了！

如果能简单得出 JS `this`乱的原因，那就不要搞那么多解释来解释这个原因了？？？

➹：[怎样理解奥卡姆剃刀原则「如无必要，勿增实体」中的「必要」和「实体」？ - 知乎](https://www.zhihu.com/question/25527032)

➹：[「奥卡姆剃刀原则」是正确的吗？ - 知乎](https://www.zhihu.com/question/20159241)

---

💡：统一把方法叫做「函数」

把函数甩给谁，`this`就是谁，如果我把一个函数甩到一个对象上作方法，如`arr.show = show`，那么这个`show`函数就变成对方的东西了！

同理，如果我把一个函数甩到一个地方去给人当事件处理器（事件触发时会运行的代码块，也叫事件监听器，用来监听事件发生，当然这也处理事件，总之，处理器就是对事件发生做出的回应），那么这个`this`就变成了那个事件触发元素了……如`document.onclick = show`

可以看到，从写法的角度来看，`arr.show = show` 和 `document.onclick = show` 其实是一样的……

> 给一个东西当方法，跟你去给某个东西加一个事件，从写法角度上来看，是完全一样的！

事件`onclick`本质上就是一个方法 -> 当某一个事发生的时候，如用户点击这个事发生的时候，`document`就会调用自己的`onclick`方法！

总之，**方法和事件是一回事儿**！

而定时器之所有把`this`指向`window`，是因为定时器是属于`window`的！

### <mark>4）小结</mark>

1. 谁调用
   1. arr.aaa();      // aaa:this -> arr
   2. setTimeout(aaa,1000) // this -> window
2. js 的 this 混乱的原因——js 太灵活

> 定时器指的是谁？ -> 我猜是`aaa`，因为类比事件监听器！延时 1000 ms 执行`aaa`，相当于 1s 后触发事件，而定时器属于`window`的，所以`aaa`的`this`指向的是`window`

`this`是一个实用性很强的东西！在用的过程中，你会体会到它的各种各样的用法！

### <mark>5）操作 this</mark>

我们希望操作`this`，换言之，我们想把`this`变成自己想要的那个东西，不管啥规则，我们想`this`是啥就是啥！

有以下两种姿势：

1. 函数的方法：call、apply、bind
2. 箭头函数 -> ES6 推出的特性
   1. 可简化函数的写法
   2. 修正 this 的指向

💡：函数也是一个对象，它也有自己的方法

![函数也是对象](assets/img/2021-02-23-20-11-34.png)

> JS 里边一切都是对象，所以把函数看成是对象也不奇怪了！

所有`function`都是`Function`这个类的实例！

#### <mark>1、call 的一个参数就是`this`</mark>

```
fn.call(thisObj[,arg1,...])
```

#### <mark>2、apply 的第一个参数就是 `this`</mark>

``` js
fn.apply(thisObj,[arg,...])
```

call vs apply -> 传参方式不一样

#### <mark>3、bind</mark>

call 和 apply 是直接执行了函数，而 bind 则是**生成一个新的函数** -> 新函数里边的`this`已经被绑定过了！

![bind](assets/img/2021-02-23-20-29-48.png)

用途：事件触发时固定监听器的`this` -> React

![事件](assets/img/2021-02-23-20-36-13.png)

> 可以认为 Java 里边的 函数都被`bind`过了，即`this`是不会变的！一直把`this`牢牢绑住了某个值！

#### <mark>4、箭头函数</mark>

- 箭头函数内部的`this`**永远**跟箭头函数外部一致
  - 箭头函数所写位置的上下文的`this`值就是它里边的`this`值
- 箭头函数相当于——自带一个`bind(this)`

![箭头函数](assets/img/2021-02-23-20-54-44.png)

上下两种写法理论上是一个东西，其内部是一致的……

💡：函数里面的代码，能获取到这个函数的名字吗？

是可以的，但推荐！

具名函数：

``` js
function show() {}
console.log(show.name) // 'show'
```

匿名函数：

``` js
// 这个获取到的名字是会变的
let show = function() {}
console.log(show.name) // 'show'
```

箭头函数：

``` js
let show = () => {}
console.log(show.name) // 'show'
```

非严格模式下：

``` js
function show(){
  console.log(arguments.callee.name);
}

// or

var show = function () {
  console.log(arguments.callee.name);
}

show();
```

严格模式下：

![严格模式下](assets/img/2021-02-23-20-59-48.png)

> caller 是调用者，callee 是函数本身

➹：[JavaScript：匿名函数和具名函数 - 有猫的程序员](http://hongliya.me/post/javascript_anonymous_function/)

💡：类的实例方法，能用箭头函数吗？

类里边不支持这种写法

对象里边可以，但不建议用，因为箭头函数里边的`this`很有可能是`window`

![箭头函数](assets/img/2021-02-23-21-30-40.png)

全局下也有个`this`，它指向的是`window`，而我测试了一下`window.this`结果是`undefined`……

💡：小结？

- 非严格模式下的 this——找不到明确的 this，算 window
- 严格模式下——找不到，算 undefined

### <mark>6）继承</mark>

如果你用了面向对象，写了一堆的 class，但是你完全没用到继承 -> **你最多撑死发挥出面向对象它的能力的 20%~30%**（不能再多了，顶天了）

在老师看来，继承才是面向对象的精华，或者说它才是我们使用 OO 的目的！

我之所以要把它写成类等之类的东西，我的目的就是将来可以继承来继承去这样 -> 很灵活

#### <mark>1、继承特别常见（整个语言到处都是继承）</mark>

JS 里边合法的类，都是 Object 的子类

常见 1：

![常见 1](assets/img/2021-02-24-09-45-27.png)

常见 2：

![常见 2](assets/img/2021-02-24-09-48-39.png)

```
oTxt -> HTMLInputElement -> HTMLElement -> Element -> Node
```

> class 是 Class 的实例？

为啥要搞那么多级别？不能直接 `oTxt -> Object`吗？

这就引出了「继承的目的」这个话题了！

---

💡：真得是互相继承吗？

- `Object instanceof Function`  -> true
- `Function instanceof Object` -> true
- `Function.constructor` -> Function
- `Function.constructor.constructor` -> 还是 Function
- `({}) instanceof Function` -> false
- `({}) instanceof Object` -> true

> 互相继承？ -> 很奇怪……还有 A 是 B 的子类，B 是 C 的子类，但是 A 却不是 C 的子类

解释：把 `Function` 当对象看，`Function` 就是 `Object` 的实例！而把`Object`当对象看，那么它的`__proto__`就是`Function`的原型！

![函数对象](assets/img/2021-02-24-11-02-26.png)

➹：[javascript 中 Function.prototype 是对象还是函数？- 方应杭的回答 - 知乎](https://www.zhihu.com/question/443856595/answer/1727571183)

➹：[JavaScript 中的 class 是一等公民吗？ - 方应杭的回答 - 知乎](https://www.zhihu.com/question/445944258/answer/1745465118)

➹：[从探究 Function.__proto__===Function.prototype 过程中的一些收获 · Issue #13 · jawil/blog](https://github.com/jawil/blog/issues/13)

➹：[彻底搞懂 Object 和 Function 的关系](https://juejin.cn/post/6844903635600556039)

➹：[面试官问：JS 的继承 - 知乎](https://zhuanlan.zhihu.com/p/57336944)

💡：HTML 上的全局属性？

**全局属性**是所有 HTML 元素共有的属性；它们可以用于所有元素，即使属性可能对某些元素不起作用。

➹：[全局属性 - HTML（超文本标记语言） - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes)

---

#### <mark>2、继承的目的？</mark>

它有几个方向上的目的：

1. 让这些类拥有清晰的层次
   1. 代码阅读方便、维护方便 
   2. 公共操作/属性 -> 放在特定的某个级别里边
2. 功能得到重用（属性、方法）
3. 使用多态来简化程序

解释第一点：

![第一点](assets/img/2021-02-24-11-45-48.png)

解释第二点：

实现`appendChild`等这样的方法，可以放在 Node 这一级这样写，也可以放在`HTMLDivElement`这一级自己实现，但其同类`HTMLInputElement`呢？也要自己实现吗？ -> 这岂不是有病吗？

解释第三点：

![背景色](assets/img/2021-02-24-11-56-58.png)

![效果](assets/img/2021-02-24-12-01-24.png)

> 大家都是猜拳，但有人出的是剪刀，有人出的是石头…… -> 而我们在写代码的过程中，只管猜拳，不管它具体出了什么，这样就能简化程序了……

#### <mark>3、适用场景</mark>

在写代码前，你一定要知道继承的使用场景啥，总不能像万金油一样，不管啥情况，就直接用吧！ -> 不能滥用，不用代码起初写没事儿，但越写，之后就挂了！

考虑的问题：什么时候要继承？什么时候不要继承？我要继承谁？怎么继承？等等……

> 三思而后行

1. 拥有明确的、合理的父子关系
2. 子类能够完全覆盖父类（子类 >= 父类）

解释第一点：

你觉得 `SVGELement` 继承 `CommentNode` 靠谱吗？画图跟注释是也给性质的吗？

显然不靠谱！

话说，怎么算是合理的父子关系呢？ -> 自己琢磨，具体问题具体分析 -> 可没有特别明确的公式可以确定出这种关系

解释第二点：

父类所拥有的所有东西，子类全都有 -> 毕竟，在继承的时候，子类就把父类的所有东西都拿到自己身上了！

反过来说，**子类可以比父类多一点东西**……

如：

1. Staff 员工 -> 有`name`、`salary`工资 -> 很泛
2. Coder extends Staff -> 继承了 Staff 天然就有`name`和`salary`这两个属性，你啥都不用写，就有了这两个属性
   1. **比父类多一点东西** -> 如`language`，如果是前端就`JS`，后端就`Java`之类的

---

什么时候适合用继承以及从哪个父类继承合适？ -> 这是**一个极其经验化的东西**！ -> 这个东西，很难用一个公式就能描述出来的，如你不能这样：

1. 如果这样，那就这样
2. 如果不这样，那就不这样

当然，如果你用习惯了继承，这是一个挺明确的东西！

> 关键词：合理、大于等于

#### <mark>4、举例子</mark>

- 实例：DatePicker extends Component -> 一个非常合理的继承
  - 页面当中有很多组件，如按钮、弹出框、选择框、日期选择器等等这些组件 -> 这些组件它们都可以有一些通用的东西：
    - 数据变化时，它们都需要被重新渲染
    - 绑定数据在它们身上 -> 对这些数据进行各种各样的操作
  - 这些都是非常通用东西，而我们需要单独为每个组件都实现一套吗？ -> 显然不需要，**搞一个总的，让这些组件继承它就完事儿了**
- 实例：ImageFile extends File
  - JS 不仅能搞前端，还能搞后台的东西
    - File 是一个非常通用的类，代表一个文件 -> 有文件名、读写操作
    - ImageFile 继承 File 就非常合理了，你看图片有文件名吧？可以读写吧？ -> 图片它特有的（比父级多出来的东西） -> 宽高、色深、格式等这样的属性
- 实例：File extends User  -> **不合理的例子**
  - User 有 name ，File 有 name 、size
  - 你不能看到 User 有 name，你就让 File 去继承它 -> 因为它们是两套体系的东西，一个是操作用户，一个是操作文件的，即便属性能覆盖，但也不合适！

要不要继承？简单遵守两条原则就好了：

1. 父子关系合理吗？
2. 子类大于等于父类吗？

### <mark>7）继承的写法</mark>

你再怎么明白，不写出来是没有意义的！

#### <mark>1、概念</mark>

在写之前，了解一些概念，这样写起来的时候就方便多了！

跟继承相关专用的概念：

1. 父类：被继承的类
   1. 其它叫法：基类（C/C++ ）、超类（Java）
   2. JS 喜欢混合着叫 -> 大部分人喜欢叫父类
   3. 你要记住的：三种称呼指得都是同一个事儿！
2. 子类：通过继承出来的新的类
   1. 其它叫法：派生类（Java）、衍生类
   2. 再次说明：不管哪种叫法，你知道它们都是一回事就行了，跟人对话的时候，人家说「派生类」，你还不知道这是指「子类」，那就尴尬了！
3. 继承
   1. 这个动词、动作本身也有很多叫法，如「派生」
   2. 我拿这个类然后派生了一个新类出来 -> 这是在说继承
4. 抽象类
   1. 本身无法直接实例化、仅仅作为父类使用（公共的功能、方法、函数、属性）
      1. 如 Node 节点，我们不能在页面上放一个 Node 的玩意儿，只能放一个元素节点、文本节点等
      2. 我们无法放一个 Node 出来
   2. *JS 本身不支持抽象类
      1. 对于 JS 来说，抽象类就是一个概念

在支持抽象类的语言里边：

``` JAVA
abstract class Node {

}
let n = new Node() // Node 不能被实例化
```

记住这种感觉，无法被实例化的感觉！

> 如果网页是个世界，那么抽象类的实例是不存在的！

#### <mark>2、写法</mark>

> 再伟大的思想，也需要一个空壳来装它，否则无法落地！

介绍两种写法：

1. 传统 -> 不好看，不好用
2. ES6 -> 好看，好用

接下来要学的：

1. 怎么写
2. 例子

💡：JS 是不是越来越像 Java 了？

不是，都是互相抄，互相借鉴 -> JS 的箭头函数 抄 python 的 lambda，迭代器抄 Java

很多语言都会抄 Java，因为 Java 这个语言的语法成熟程度在所有语言里边绝对是排名第一的！

Java 的语法严谨性在所有语言里边是数一数二的！

所以，其它语言抄它，一点也不奇怪，如 PHP7……

----
