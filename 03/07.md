### ✍️ Tangxt ⏳ 2021-02-27 🏷️ 可响应对象

# 07-可响应对象-2

1）设置值，触发重新渲染

💡：不要重复渲染？

搞一个 `_updated` 私有属性

![不要重复渲染](assets/img/2021-02-27-15-55-13.png)

💡：想要这种调用方式： `app.data.a = 666` -> 触发 `render`

需要自己去递归处理 -> 处理不好影响性能，处理好了，代码丑陋！

![很麻烦](assets/img/2021-02-27-17-10-22.png)

2）重写 HotList

💡： `constructor` 里边不要搞那么多操作，有价值的操作就提取出来成为一个方法！

> 在写断言的时候，时常来一句：我这要求过分吗？

``` js
class HotList {
  //parent自动判断
  constructor(options) {
    assert(options, "options必须有");
    // 把需要搞很多断言的操作抽出去
    this._root = this._getRoot(options);
    this._defineData(options);

    this.render();

    this._update = false;
  }

  _getRoot(options) {
    // 我这要求过分吗？
    assert(options.root, "root不能为空");

    if (typeof options.root == "string") {
      let root = document.querySelector(options.root);
      assert(root, `找不到: ${options.root}`);

      return root;
    } else if (options.root instanceof HTMLElement) {
      return options.root;
    } else {
      assert(false, "root不合法");
    }
  }

  _defineData(options) {
    assert(options.data, `data不能没有`);
    assert(typeof options.data == "function", `data必须是函数`);

    let data = options.data();
    assert(data, "data必须有返回值");
    assert(typeof data == "object", "data必须是object");

    //
    for (let name in data) {
      Object.defineProperty(this, name, {
        configurable: true,
        get() {
          return data[name];
        },
        set(val) {
          data[name] = val;

          this.render();
        },
      });
    }
  }

  // 修改数组元素里边的内容，强制 render！
  $set(obj, name, val) {
    this._update = false;
    obj[name] = val;

    if (!this._update) {
      this.render();
    }
  }

  render() {
    let div = document.createElement("div");
    div.className = "v-hd";
    div.innerHTML = this.title;

    let ul = document.createElement("ul");
    ul.className = "user-list";

    let arr = [];
    this.data.forEach((data) => {
      arr.push(`
        <li class="row">
          <a href="${data.href}" class="cver">
            <img src="${data.avatar}" alt="">
          </a>
          <div class="info">
            <p class="row aic">
              <a href="${data.href}" class="nm-icn">${data.name}</a>
              ${data.vip ? '<img src="./img/vip.png" alt="">' : ""}
            </p>
            <p class="label">${data.title}</p>
          </div>
        </li>
      `);
    });
    ul.innerHTML = arr.join("");

    //
    this._root.innerHTML = "";
    this._root.appendChild(div);
    this._root.appendChild(ul);

    this._update = true;
  }
}

let list = new HotList({
  root: ".hot-host",
  data() {
    return {
      title: "热门主播",
      data: [{
          name: "blue",
          href: "http://www.zhinengshe.com/",
          avatar: "img/1407374893913311.jpg",
          vip: false,
          title: "打杂的",
        },
        {
          name: "blue",
          href: "http://www.zhinengshe.com/",
          avatar: "img/1407374893913311.jpg",
          vip: false,
          title: "打杂的",
        },
        {
          name: "blue",
          href: "http://www.zhinengshe.com/",
          avatar: "img/1407374893913311.jpg",
          vip: false,
          title: "打杂的",
        },
      ],
    };
  },
});
```

3）Proxy

> defineProperty 能用，但它不靠谱，为何不用靠谱的东西呢？

Proxy 的前身是 Observe，但它已经被废弃掉了！

1、怎么用

1. 准备一个真实数据 -> 此数据是要藏在背后的，不会被人去修改
2. `new Proxy` -> 代理，你找他有事？先跟我说吧！

   1. 第一个参数 -> 我要监听谁
   2. 第二个参数 -> `{}` -> 里边提供了好几种方法，原先的 `defineProperty` 过于复杂，取消掉了一些东西 -> 以下这些函数需要返回值，不然返回 `undefined` 的话，就是 `false` 了 -> 对代理做某些操作，会触发以下相应的某些行为

      1. has -> `xxx in {}` -> 返回`ture/false` -> **`in`触发**
      2. get -> 获取
      3. set -> 设置
      4. deleteProperty -> 处理delete -> 不叫delete，是以防与`delete`关键字重名 -> **`delete`触发**

         1. 从哪儿删
         2. 删谁

基本使用（没有解决 `arr` 值没有被监听的问题）：

``` js
//真实数据
let _data = {
  a: 12,
  arr: [1, 2, 3],
  json: {
    a: 12,
    b: 5
  },
};

let p = new Proxy(_data, {
  has(data, name) {
    //in
    if (name in data) {
      return true;
    } else {
      return false;
    }
  },
  get(data, name) {
    //获取
    if (name in data) {
      return data[name];
    } else {
      throw new Error(`${name} is not defined`);
    }
  },
  set(data, name, val) {
    //设置
    console.log("set");
    data[name] = val;
  },
  deleteProperty(data, name) {
    //处理delete
    if (name in data) {
      return delete data[name];
    } else {
      throw new Error(`${name} is not defined`);
    }
  },
});
```

这玩意儿，目前在用法上是不方便的！因为你要监听一个对象，都得 `new Proxy(_data,{})` 这样包裹一层！

2、介绍两个对它在使用上至关重要的东西

跟函数配合：

如何才能跟函数配合？

1. 前提条件：监听的东西也得是个函数，不用我们无法调用`p` -> `new Proxy`的第一个参数是函数的话，那么返回值也是函数
2. 使用 `apply` 这个参数 -> `{has,apply}`

   1. `apply` 有三个参数 -> `fn/thisValue/args`

> Proxy 它不仅可以用来包装一个数据，还可以用来包装一个函数！

![apply参数](assets/img/2021-02-27-19-14-46.png)

目前，我们试了 json，函数，接下来试一下数组！

跟数组配合：

``` js
let _data = [1, 2, 3];

let p = new Proxy(_data, {
  get(data, name) {
    console.log("get");
    return data[name];
  },
  set(data, name, val) {
    console.log("set");
    data[name] = val;
  },
});
```

在`push`元素时，`set`报错了：

![报错](assets/img/2021-02-27-19-23-09.png)

跟类打交道：

> 这个很重要

`construct`用来处理`new`的！在你`new`的时候，会拦截你这个操作 -> 这可不是`constructor`

注意点：不需要传`this`，因为`new`的时候就确定`this`是实例了！

![配合类](assets/img/2021-02-27-19-33-12.png)

如果你不返回一个`{}/[]`等，那么就会报错：

![报错](assets/img/2021-02-27-19-34-28.png)

3、小结

分情况使用这 6 个东西：

- has -> in
- get -> 获取
- set -> 赋值（push、pop等操作，很复杂，会同时改动多个东西）
- deleteProperty -> 删除 -> 需要返回`in`操作的结果
- apply -> 函数调用 -> 原先那个定义属性API是无法检测函数被调用的！
- construct -> new

4）监听一个`class`里边所有的属性

一旦属性被改动了，就得收到通知！

监听对象：

![class](assets/img/2021-02-27-19-58-18.png)

用户在使用时不方便 -> 需要用`let a = new Proxy()`这样包裹一层使用`a`实例

监听类（类似高阶类）：

![监听类](assets/img/2021-02-27-20-06-22.png)

---

这两种姿势，显然后者好！`Proxy` 相较于 `Object.defineProperty`：

1. 强大多了 -> 多了好多功能
2. 也多了很多复杂 -> 用起来要更复杂一些

5）例子

> 透过例子，进一步深入理解这个`Proxy`













